SYMBOLS {
  # the maximum size of a single line (also the size of the line buffer)
  __LINESIZE__:  type = export, value = 40;
}

MEMORY {
  LINEBUFF:
    start = $0800
    size = __LINESIZE__*3+1;

  SIDBUFF:
    start = $1000
    size  = $1000,
    fill  = no;

  SPARE:
    start = $900
    size  = $1000;

  BOOT:
    start = $07ff
    size  = $201
    fill  = yes;

  RAM:
    start = $0a00
    size  = $d000-$a00-$90
    fill  = no;

  HIRAM:
    start = $d000
    size  = $3000;

  LABELS_BANK:
    start = $000000
    size  = $ffff;

  OBJ_BANK:
    start = $000000
    size  = $ffff;

  MACRO_BANK:
    start = $000000
    size  = $ffff;

  BUFF_BANK:
    start = $000000
    size  = $ffff;

  CTX_BANK:
    start = $000000
    size  = $ffff;

  # small buffer that stores the routine used for stepping through code
  STEPHANDLER:
    start = $d000-$7d
    size  = $7d;

  # small buffer to jump to
  TRAMPOLINE:
    start = $d000-$94
    size  = $17;

  NMIHANDLER:
    start = $d000-$100
    size  = $60;
}

SEGMENTS {
	# SETUP (for bootloader)
	SETUP: load = BOOT, type = rw, define = yes;

	# DATA SEGMENTS
	DATA: load = RAM, run = RAM, type = rw, define = yes;

	# RODATA SEGMENTS
	RODATA: load = RAM, run = RAM, type = ro, define = yes;

	# CODE SEGMENTS
	IRQ:            load = RAM, run = RAM, type = ro, define = yes;
	DEBUGGER:       load = RAM, run = RAM, type = ro, define = yes;
	DEBUGINFO_CODE: load = RAM, run = RAM, type = ro, define = yes;
	CODE:           load = RAM, run = RAM, type = ro, define = yes;
	COPYBUFF:       load = RAM, run = RAM, type = ro, define = yes;
	MACROCODE:      load = RAM, run = RAM, type = ro, define = yes;
	CONSOLE:        load = RAM, run = RAM, type = ro, define = yes;
	EXPR:           load = RAM, run = RAM, type = ro, define = yes;
	HELP:           load = RAM, run = RAM, type = ro, define = yes;
	LABELS:         load = RAM, run = RAM, type = ro, define = yes;
	LINKER:         load = RAM, run = RAM, type = ro, define = yes;
	OBJCODE:        load = RAM, run = RAM, type = ro, define = yes;
	BANKCODE2:      load = RAM, run = RAM, type = ro, define = yes;
	CTX:            load = RAM, run = RAM, type = ro, define = yes;

	STEPHANDLER:   load = RAM, run = STEPHANDLER, type = rw, define = yes;
	STEP_EPILOGUE: load = RAM, run = STEPHANDLER, type = rw, define = yes;
	NMI_HANDLER:   load = RAM, run = NMIHANDLER, type = rw, define = yes;
	TRAMPOLINE:    load = RAM, run = TRAMPOLINE,  type = rw, define = yes;

	# BSS SEGMENTS
	LINEBUFF: load = LINEBUFF, type = bss;
	SPARE:    load = SPARE, type = bss;
	SIDBUFF:  load = SIDBUFF, type = bss, define = yes;

	SHAREBSS:       load = RAM, type = bss;
	BSS_NOINIT:     load = RAM, type = bss, define = yes;
	VSYSRAM:        load = RAM, type = bss, define = yes;
	BSS:            load = RAM, type = bss, define = yes;
	SIMBSS:         load = RAM, type = bss, define = yes;

	# main memory variables
	DEBUGINFO_VARS: load = RAM, type = bss;
	DEBUGINFO_BSS:  load = HIRAM, type = bss;
	COPYBUFF_VARS:  load = HIRAM, type = bss, define = yes;
	CONSOLE_VARS:   load = HIRAM, type = bss;
	MACRO_VARS:     load = HIRAM, type = bss;
	LINKER_VARS:    load = HIRAM, type = bss, define = yes;
	OBJVARS:        load = HIRAM, type = bss, define = yes;

	DEBUGINFO:    load = RAM, type = bss;
	CONSOLE_BSS:  load = HIRAM, type = bss;
	EXPR_BSS:     load = HIRAM, type = bss;

	LABELMODES:   load = HIRAM, type = bss;

	# the following BSS segments may live in the REU
	LABEL_BSS:    load = LABELS_BANK, type = bss;
	LABELNAMES:   load = LABELS_BANK, type = bss;

	OBJBSS:       load = OBJ_BANK,  type = bss, define = yes;
	LINKER_BSS:   load = OBJ_BANK,  type = bss, define = yes;
	COPYBUFF_BSS: load = BUFF_BANK, type = bss, define = yes;

	CTX_BSS:      load = CTX_BANK,   type = bss;
	MACROBSS:     load = MACRO_BANK, type = bss;
}
